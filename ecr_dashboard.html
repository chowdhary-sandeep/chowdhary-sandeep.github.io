<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ECR Skills & Mentorship Directory</title>
  <style>
    :root {
      --bg: #ffffff;
      --panel: #f5f5f5;
      --panel-2: #e0e0e0;
      --text: #000000;
      --muted: #666666;
      --accent: #000000;
      --accent-2: #000000;
      --warn: #000000;
      --chip-bg: #ffffff;
      --chip-border: #000000;
      --ok: #000000;
      --bad: #000000;
      --card: #ffffff;
      --shadow: none;
      --radius: 0px;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text); font-family: 'Courier New', monospace; font-weight: 400; }
    a { color: var(--accent); text-decoration: underline; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
    header { display: grid; gap: 20px; margin-bottom: 20px; }
    .title { font-size: 32px; font-weight: 900; letter-spacing: -1px; text-transform: uppercase; }
    .subtitle { color: var(--muted); font-weight: 400; }
    .toolbar { display: grid; grid-template-columns: 1fr auto auto; gap: 10px; }
    .search { display: flex; align-items: center; gap: 10px; background: var(--panel); border: 2px solid var(--chip-border); padding: 12px; }
    .search input { flex: 1; background: transparent; border: none; outline: none; color: var(--text); font-size: 16px; font-family: 'Courier New', monospace; }
    .btn { background: var(--bg); border: 2px solid var(--chip-border); color: var(--text); padding: 12px 16px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: 700; text-transform: uppercase; }
    .btn:hover { background: var(--text); color: var(--bg); }
    .btn:active { background: var(--muted); }
    .segment { background: var(--panel); border: 2px solid var(--chip-border); padding: 16px; }
    .chips { display: flex; flex-wrap: wrap; gap: 8px; }
    .chip { display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; background: var(--chip-bg); border: 2px solid var(--chip-border); font-size: 12px; cursor: pointer; font-family: 'Courier New', monospace; font-weight: 700; text-transform: uppercase; }
    .chip.offer { background: var(--bg); border-color: var(--text); }
    .chip.seek { background: var(--text); color: var(--bg); border-color: var(--text); }
    .chip.method { background: var(--bg); border-color: var(--text); }
    .chip.soft { background: var(--bg); border-color: var(--text); }
    .chip.tag { background: var(--text); color: var(--bg); border-color: var(--text); }
    .chip .x { font-weight: 900; margin-left: 4px; }
    .chip.unknown { opacity: .5; border-style: dashed; }
    .active-filters { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 14px; }
    .left { grid-column: span 5; }
    .right { grid-column: span 7; }
    @media (max-width: 1000px) {
      .toolbar { grid-template-columns: 1fr; }
      .grid { grid-template-columns: 1fr; }
      .left, .right { grid-column: auto; }
    }
    .card { background: var(--card); border: 2px solid var(--chip-border); padding: 16px; display: grid; gap: 12px; }
    .card:hover { border-color: var(--text); }
    .card .head { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .name { font-weight: 900; font-size: 18px; text-transform: uppercase; }
    .meta { font-size: 12px; color: var(--muted); font-weight: 700; }
    .desc { color: var(--text); font-size: 14px; line-height: 1.4; }
    .badges { display: flex; flex-wrap: wrap; gap: 8px; }
    .pill { font-size: 10px; padding: 6px 10px; background: var(--panel-2); border: 2px solid var(--chip-border); font-family: 'Courier New', monospace; font-weight: 700; text-transform: uppercase; }
    .pill.program { color: var(--text); }
    .pill.group { color: var(--text); }
    .legend { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .legend .chip { cursor: default; }
    .tabs { display: inline-flex; background: var(--panel); border: 2px solid var(--chip-border); }
    .tab { padding: 12px 16px; cursor: pointer; font-size: 12px; border-right: 2px solid var(--chip-border); font-family: 'Courier New', monospace; font-weight: 700; text-transform: uppercase; }
    .tab:last-child { border-right: none; }
    .tab.active { background: var(--text); color: var(--bg); }
    .cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; }
    .group-block { background: var(--panel); border: 2px solid var(--chip-border); padding: 16px; }
    .group-title { font-weight: 900; margin-bottom: 12px; text-transform: uppercase; }
    .muted { color: var(--muted); }
    .highlight-offer { outline: 3px solid var(--ok); }
    .highlight-seek { outline: 3px solid var(--bad); }
    .progress-wrap { position: relative; height: 8px; background: var(--panel-2); border: 2px solid var(--chip-border); }
    .progress-bar { position: absolute; top:0; left:0; height:100%; width:0%; background: var(--text); transition: width .3s ease; }
    .small { font-size: 12px; }
    .footer { margin-top: 20px; display: flex; justify-content: space-between; align-items: center; color: var(--muted); font-weight: 700; }
    .toast { position: fixed; bottom: 20px; right: 20px; background: var(--bg); border: 2px solid var(--chip-border); padding: 16px; display:none; font-weight: 700; }
    .toggle-container { display: flex; align-items: center; gap: 20px; background: var(--panel); border: 3px solid var(--chip-border); padding: 20px; margin-bottom: 20px; }
    .toggle-label { font-weight: 900; font-size: 16px; text-transform: uppercase; }
    .toggle-switch { position: relative; width: 120px; height: 40px; background: var(--bg); border: 3px solid var(--chip-border); cursor: pointer; }
    .toggle-slider { position: absolute; top: 3px; left: 3px; width: 50px; height: 30px; background: var(--text); transition: transform 0.3s ease; }
    .toggle-switch.active .toggle-slider { transform: translateX(60px); }
    .toggle-text { position: absolute; top: 50%; transform: translateY(-50%); font-weight: 700; font-size: 10px; text-transform: uppercase; }
    .toggle-left { left: 8px; color: var(--bg); }
    .toggle-right { right: 8px; color: var(--text); }
    .toggle-switch.active .toggle-left { color: var(--text); }
    .toggle-switch.active .toggle-right { color: var(--bg); }
    .record-counter { font-weight: 900; font-size: 14px; color: var(--text); }
    .record-counter .count { color: var(--accent); }
  </style>
</head>
<body>
  <div class="container">
    <div class="toggle-container">
      <div class="toggle-label">Dataset:</div>
      <div class="toggle-switch" id="datasetToggle">
        <div class="toggle-slider"></div>
        <div class="toggle-text toggle-left">ECR</div>
        <div class="toggle-text toggle-right">All IIASA</div>
      </div>
      <div class="record-counter">
        Total Records: <span class="count" id="recordCount">0</span>
        <span id="datasetStatus" style="margin-left: 10px; font-size: 12px; color: var(--muted);">(ECR only)</span>
      </div>
    </div>
    <header>
      <div class="title">ECR Skills & Mentorship Directory</div>
      <div class="subtitle">Find people who <b>offer</b> help. Search by skill, method, software, background, or name. Click tags to filter.</div>
      <div class="toolbar">
        <div class="search">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M21 21l-4.35-4.35M10.5 18a7.5 7.5 1 1 1 0-15 7.5 7.5 0 0 1 0 15Z" stroke="currentColor" stroke-width="2"/></svg>
          <input id="q" placeholder="Search skills, names, programs, groups, methods, software, topicsâ€¦" />
        </div>
        <div class="tabs">
          <div class="tab active" data-view="list">List View</div>
          <div class="tab" data-view="skills">Skill View</div>
        </div>
        <button id="randomConnect" class="btn">ðŸŽ² Random Connect</button>
      </div>
      <div class="legend"></div>
      <div id="activeFilters" class="active-filters"></div>
      <div class="segment" style="margin-top:10px">
        <div class="small muted" id="eta">Preparing directoryâ€¦ 0%</div>
        <div class="progress-wrap"><div id="prog" class="progress-bar"></div></div>
      </div>
    </header>

    <main class="grid">
      <section class="left">
        <div id="listView" class="cards"></div>
        <div id="skillView" style="display:none;"></div>
      </section>
      <aside class="right">
        <div class="segment">
          <div class="group-title">Skill â†” People map</div>
          <canvas id="net" width="600" height="420" style="width:100%;height:auto;background:var(--panel-2);border:2px solid var(--chip-border);"></canvas>
          <div id="networkInstructions" style="margin-top: 10px; font-size: 12px; color: var(--muted); text-align: center;">
            Click nodes to see ego network. <span id="shiftInstructions" style="display: none;">Shift+click for extended network (order 2).</span>
          </div>
          <div class="small muted">Interactive network: skills (squares) and people (circles). Click any node to see its direct connections (bright) and order 2 network (faint).</div>
        </div>
        <div class="segment">
          <div class="group-title">Tips</div>
          <ul class="small muted">
            <li>Type a skill (e.g., <b>GIS</b>, <b>Python</b>) to highlight who offers it.</li>
            <li>Click any tag to add it as a filter; click the âœ• to remove.</li>
            <li>Click nodes in the network to see ego networks (bright) and order 2 connections (faint).</li>
            <li>Use <b>Skill View</b> to see people grouped by offered skill.</li>
          </ul>
        </div>
      </aside>
    </main>

    <div class="footer small">
      <div>Built as a single HTML file. No servers. Share freely.</div>
      <div id="count"></div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    // Data and vectors (loaded from static JSON files)
    let DATA = [];
    let CARD_VECS = new Map(); // name -> Float32Array
    let TOKEN_VECS = new Map(); // token(lowercase) -> Float32Array
    let STAFF_DATA = [];
    let STAFF_CARD_VECS = new Map();

    // Progress/ETA simulation for UX
    const prog = document.getElementById('prog');
    const eta = document.getElementById('eta');
    let pct = 0;
    const timer = setInterval(() => {
      pct = Math.min(100, pct + Math.random()*18);
      prog.style.width = pct + '%';
      eta.textContent = 'Preparing directoryâ€¦ ' + Math.floor(pct) + '%';
      if (pct >= 100) { clearInterval(timer); eta.textContent = 'Ready âœ”'; }
    }, 180);

    // Utilities
    const byId = (id) => document.getElementById(id);
    const norm = (s) => (s||'').toString().toLowerCase();
    const uniq = (arr) => Array.from(new Set(arr));
    const flatten = (arr) => [].concat(...arr);

    let allSkillsOffered = [];
    let allMethods = [];
    let allSoftware = [];

    // State
    let activeView = 'list';
    let filters = [];
    let query = '';
    let semanticSeed = '';
    let similarityScores = new Map(); // name -> score
    let similarityThreshold = 0.42;
    let selectedNode = null;
    let includeStaff = false;
    let showOrder2 = false;

    const listEl = byId('listView');
    const skillEl = byId('skillView');
    const qEl = byId('q');
    const countEl = byId('count');

    function addFilter(token) {
      token = norm(token); if (!token) return;
      if (!filters.includes(token)) filters.push(token);
      renderFilters(); render();
    }
    function onBadgeClick(label) {
      addFilter(label); setSemanticSeed(label); qEl.value = label; query = label; selectedNode = null;
    }
    function removeFilter(token) {
      token = norm(token); filters = filters.filter(t => t !== token); renderFilters(); selectedNode = null; render();
    }
    function clearSemanticSeed() { semanticSeed = ''; similarityScores = new Map(); selectedNode = null; render(); }
    function renderFilters() {
      const wrap = byId('activeFilters');
      const chips = filters.map(t => `<span class="chip"><span>${t}</span><span class="x" onclick="removeFilter('${t.replace(/'/g,"\\'")}')">âœ•</span></span>`).join('');
      const sem = semanticSeed ? `<span class="chip"><span>semantic: ${semanticSeed}</span><span class="x" onclick="clearSemanticSeed()">âœ•</span></span>` : '';
      wrap.innerHTML = chips + (chips && sem ? ' ' : '') + sem;
    }

    function matchRecord(r, tokens) {
      const hay = [ r.name, r.program, r.group, r.background, r.topic, ...r.methods, ...r.software, ...r.offer, ...(r.tags || []) ].map(norm).join(' | ');
      return tokens.every(t => hay.includes(t));
    }

    function filteredData() {
      const tokens = uniq([ ...filters, ...norm(query).split(/\s+/).filter(Boolean) ]);
      const arr = DATA.filter(r => matchRecord(r, tokens));
      if (!semanticSeed || similarityScores.size === 0) return arr;
      return arr.map(r => ({ r, s: (similarityScores.get(r.name) ?? 0) })).sort((a,b) => b.s - a.s).map(x => x.r);
    }

    function badge(label, cls='') {
      const safe = label.replace(/\"/g, '&quot;');
      return `<span class="chip ${cls}" onclick="onBadgeClick('${safe.replace(/'/g,"\\'")}')">${safe}</span>`;
    }

    function renderList() {
      const data = filteredData();
      listEl.innerHTML = data.map(r => {
        const offers = r.offer.map(s => badge(s, 'offer')).join(' ');
        const meth = r.methods.map(s => badge(s, 'method')).join(' ');
        const soft = r.software.map(s => badge(s, 'soft')).join(' ');
        const tags = (r.tags || []).map(s => badge(s, 'tag')).join(' ');

        const qtok = norm(query).trim();
        const isOfferHit = qtok && r.offer.map(norm).includes(qtok);
        const highlight = isOfferHit ? 'highlight-offer' : '';
        const score = similarityScores.get(r.name) ?? 0;
        const inCluster = semanticSeed && score >= similarityThreshold;

        const isStaffData = includeStaff;

        return `
        <article class="card ${highlight}" style="${inCluster? 'box-shadow: 0 0 0 2px rgba(85,214,169,.35), inset 0 0 0 1px rgba(85,214,169,.35);' : ''}">
          <div class="head">
            <div>
              <div class="name">${r.name}</div>
              <div class="meta">${r.program || (isStaffData ? '' : '??')}${(r.program||r.group) ? ' Â· ' : ''}${r.group || (isStaffData ? '' : '??')}</div>
            </div>
            <div class="badges">
              ${r.program ? `<span class="pill program">${r.program}</span>` : (isStaffData ? '' : `<span class="pill program">??</span>`)}
              ${r.group ? `<span class="pill group">${r.group}</span>` : (isStaffData ? '' : `<span class="pill group">??</span>`)}
            </div>
          </div>
          <div class="desc" title="${(r.topic||'').replace(/\"/g,'&quot;')}">
            ${r.background ? `<b>${r.background}</b>` : (isStaffData ? '' : '<b>??</b>')}${(r.background||r.topic) ? ' â€” ' : ''}${r.topic || (isStaffData ? '' : '??')}
          </div>
          <div class="badges">${offers || (isStaffData ? '' : '<span class="chip unknown">??</span>')}</div>
          ${meth ? `<div class="badges">${meth}</div>` : (isStaffData ? '' : '<div class="badges"><span class="chip unknown">??</span></div>')}
          ${soft ? `<div class="badges">${soft}</div>` : (isStaffData ? '' : '<div class="badges"><span class="chip unknown">??</span></div>')}
          ${tags ? `<div class="badges">${tags}</div>` : ''}
          ${semanticSeed ? `<div class="small" style="color: var(--muted); font-weight: 700;">similarity: ${(score).toFixed(2)}</div>` : ''}
        </article>`;
      }).join('');
      countEl.textContent = data.length + ' people';
    }

    function renderSkillView() {
      const data = filteredData();
      const map = new Map();
      data.forEach(r => {
        r.offer.forEach(s => { if (!map.has(s)) map.set(s, []); map.get(s).push(r); });
      });
      const keys = Array.from(map.keys()).sort((a,b)=>a.localeCompare(b));
      if (!keys.length) { skillEl.innerHTML = '<div class="muted">No skills match your filters.</div>'; return; }
      skillEl.innerHTML = keys.map(k => {
        const cards = map.get(k).map(r => `
          <div class="pill">${r.name}${r.program ? ' Â· ' + r.program : ''}${r.group ? ' Â· ' + r.group : ''}</div>
        `).join(' ');
        return `<div class="group-block">
          <div class="group-title">${k}</div>
          <div class="badges">${cards}</div>
        </div>`;
      }).join('');
    }

    function renderNetworkSketch() {
      const data = filteredData();
      const canvas = byId('net');
      const ctx = canvas.getContext('2d');
      const W = canvas.width, H = canvas.height;
      ctx.clearRect(0,0,W,H);

      const people = data.map(r => ({ id: 'p:'+r.name, label: r.name, type:'person', ref:r }));
      const skillsSet = new Set();
      data.forEach(r => r.offer.forEach(s => skillsSet.add(s)));
      const skills = Array.from(skillsSet).map(s => ({ id: 's:'+s, label: s, type:'skill' }));

      const cx = W/2, cy = H/2, R1 = Math.min(W,H)*0.42;

      // Grouped skill layout if staff expertise_groups available
      const expertiseGroups = new Map();
      data.forEach(r => {
        if (r.expertise_groups) {
          Object.keys(r.expertise_groups).forEach(group => {
            if (!expertiseGroups.has(group)) expertiseGroups.set(group, new Set());
            r.expertise_groups[group].forEach(skill => { expertiseGroups.get(group).add(skill); });
          });
        }
      });
      if (expertiseGroups.size === 0) expertiseGroups.set('General', skillsSet);

      const P = people.length || 1;
      const pos = new Map();
      people.forEach((n,i)=>{ const a = (i/P) * Math.PI*2; pos.set(n.id, [cx + R1*Math.cos(a), cy + R1*Math.sin(a)]); });

      const groupArray = Array.from(expertiseGroups.entries());
      groupArray.forEach(([groupName, groupSkills], groupIndex) => {
        const groupSkillsArray = Array.from(groupSkills);
        const R2 = Math.min(W,H) * (0.15 + (groupIndex * 0.08));
        const S = groupSkillsArray.length || 1;
        groupSkillsArray.forEach((skill, skillIndex) => {
          const a = (skillIndex/S) * Math.PI*2; pos.set('s:'+skill, [cx + R2*Math.cos(a), cy + R2*Math.sin(a)]);
        });
      });

      const egoConnections = new Set();
      const order2Connections = new Set();
      if (selectedNode) {
        if (selectedNode.type === 'person') {
          const person = selectedNode.ref;
          person.offer.forEach(s => { egoConnections.add('s:'+s); egoConnections.add('p:'+person.name); });
          if (!includeStaff || showOrder2) {
            person.offer.forEach(skill => {
              data.forEach(r => {
                if (r.name !== person.name && r.offer.includes(skill)) {
                  order2Connections.add('p:'+r.name);
                  r.offer.forEach(s => { if (s !== skill) order2Connections.add('s:'+s); });
                }
              });
            });
          }
        } else if (selectedNode.type === 'skill') {
          const skill = selectedNode.label;
          const peopleWithSkill = [];
          data.forEach(r => { if (r.offer.includes(skill)) { egoConnections.add('p:'+r.name); egoConnections.add('s:'+skill); peopleWithSkill.push(r); } });
          if (!includeStaff || showOrder2) {
            peopleWithSkill.forEach(person => {
              person.offer.forEach(s => {
                if (s !== skill) {
                  order2Connections.add('s:'+s);
                  data.forEach(r => { if (r.name !== person.name && r.offer.includes(s)) { order2Connections.add('p:'+r.name); } });
                }
              });
            });
          }
        }
      }

      // Edges
      ctx.lineWidth = 1;
      data.forEach(r => {
        const p = 'p:'+r.name;
        r.offer.forEach(s => {
          const sid = 's:'+s;
          const [x1,y1] = pos.get(p) || [0,0];
          const [x2,y2] = pos.get(sid) || [0,0];
          const isEgoConnection = selectedNode && (egoConnections.has(p) && egoConnections.has(sid));
          const isOrder2Connection = selectedNode && !isEgoConnection && (order2Connections.has(p) || order2Connections.has(sid));
          if (isEgoConnection) { ctx.strokeStyle = '#000000'; ctx.lineWidth = 3; }
          else if (isOrder2Connection) { ctx.strokeStyle = '#666666'; ctx.lineWidth = 1; }
          else { ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 1; }
          ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        });
      });

      // Nodes
      const groupColors = ['#000000','#333333','#666666','#999999','#cccccc'];
      skills.forEach(n=>{
        const [x,y] = pos.get(n.id);
        const isSelected = selectedNode && selectedNode.id === n.id;
        const isEgoNode = selectedNode && egoConnections.has(n.id);
        const isOrder2Node = selectedNode && !isEgoNode && order2Connections.has(n.id);
        let groupIndex = 0; groupArray.forEach(([groupName, groupSkills], idx) => { if (groupSkills.has(n.label)) groupIndex = idx; });
        if (isSelected) { ctx.fillStyle = '#000000'; ctx.strokeStyle = '#000000'; }
        else if (isEgoNode) { ctx.fillStyle = '#000000'; ctx.strokeStyle = '#000000'; }
        else if (isOrder2Node) { ctx.fillStyle = groupColors[Math.min(groupIndex, groupColors.length - 1)]; ctx.strokeStyle = groupColors[Math.min(groupIndex, groupColors.length - 1)]; }
        else { ctx.fillStyle = groupColors[Math.min(groupIndex, groupColors.length - 1)]; ctx.strokeStyle = '#000000'; }
        const size = isSelected ? 12 : 9; ctx.fillRect(x-size/2, y-size/2, size, size); ctx.strokeRect(x-size/2, y-size/2, size, size);
      });
      people.forEach(n=>{
        const [x,y] = pos.get(n.id);
        const isSelected = selectedNode && selectedNode.id === n.id;
        const isEgoNode = selectedNode && egoConnections.has(n.id);
        const isOrder2Node = selectedNode && !isEgoNode && order2Connections.has(n.id);
        ctx.beginPath(); ctx.arc(x,y,isSelected ? 7 : 5,0,Math.PI*2);
        if (isSelected) { ctx.fillStyle = '#000000'; ctx.strokeStyle = '#000000'; }
        else if (isEgoNode) { ctx.fillStyle = '#000000'; ctx.strokeStyle = '#000000'; }
        else if (isOrder2Node) { ctx.fillStyle = '#666666'; ctx.strokeStyle = '#666666'; }
        else { ctx.fillStyle = '#cccccc'; ctx.strokeStyle = '#000000'; }
        ctx.fill(); ctx.stroke();
      });

      // Draw labels with overlap avoidance
      function drawLabelsWithAvoidance() {
        const labels = [];
        
        // Collect all labels to draw
        if (selectedNode) {
          // Selected node label (highest priority)
          const [x,y] = pos.get(selectedNode.id);
          labels.push({
            text: selectedNode.label,
            x: x, y: y,
            priority: 3,
            color: '#000000',
            font: 'bold 12px "Segoe UI", "Helvetica Neue", Arial, sans-serif',
            offsetX: 10, offsetY: -8
          });
          
          // Order 1 connected nodes (high priority)
          if (selectedNode.type === 'person') {
            selectedNode.ref.offer.forEach(s => {
              const skillNode = skills.find(sk => sk.label === s);
              if (skillNode && egoConnections.has(skillNode.id)) {
                const [x,y] = pos.get(skillNode.id);
                labels.push({
                  text: s,
                  x: x, y: y,
                  priority: 2,
                  color: '#000000',
                  font: '11px "Segoe UI", "Helvetica Neue", Arial, sans-serif',
                  offsetX: 10, offsetY: -6
                });
              }
            });
          } else if (selectedNode.type === 'skill') {
            data.forEach(r => {
              if (r.offer.includes(selectedNode.label) && egoConnections.has('p:'+r.name)) {
                const [x,y] = pos.get('p:'+r.name);
                labels.push({
                  text: r.name,
                  x: x, y: y,
                  priority: 2,
                  color: '#000000',
                  font: '11px "Segoe UI", "Helvetica Neue", Arial, sans-serif',
                  offsetX: 8, offsetY: -8
                });
              }
            });
          }
          
          // Order 2 connected nodes (lower priority)
          if (selectedNode.type === 'person') {
            data.forEach(r => {
              if (r.name !== selectedNode.ref.name && order2Connections.has('p:'+r.name)) {
                const [x,y] = pos.get('p:'+r.name);
                labels.push({
                  text: r.name,
                  x: x, y: y,
                  priority: 1,
                  color: '#666666',
                  font: '10px "Segoe UI", "Helvetica Neue", Arial, sans-serif',
                  offsetX: 8, offsetY: -8
                });
              }
            });
            skills.forEach(skill => {
              if (order2Connections.has(skill.id) && !egoConnections.has(skill.id)) {
                const [x,y] = pos.get(skill.id);
                labels.push({
                  text: skill.label,
                  x: x, y: y,
                  priority: 1,
                  color: '#666666',
                  font: '10px "Segoe UI", "Helvetica Neue", Arial, sans-serif',
                  offsetX: 10, offsetY: -6
                });
              }
            });
          } else if (selectedNode.type === 'skill') {
            skills.forEach(skill => {
              if (order2Connections.has(skill.id) && !egoConnections.has(skill.id)) {
                const [x,y] = pos.get(skill.id);
                labels.push({
                  text: skill.label,
                  x: x, y: y,
                  priority: 1,
                  color: '#666666',
                  font: '10px "Segoe UI", "Helvetica Neue", Arial, sans-serif',
                  offsetX: 10, offsetY: -6
                });
              }
            });
            data.forEach(r => {
              if (order2Connections.has('p:'+r.name) && !egoConnections.has('p:'+r.name)) {
                const [x,y] = pos.get('p:'+r.name);
                labels.push({
                  text: r.name,
                  x: x, y: y,
                  priority: 1,
                  color: '#666666',
                  font: '10px "Segoe UI", "Helvetica Neue", Arial, sans-serif',
                  offsetX: 8, offsetY: -8
                });
              }
            });
          }
        } else {
          // Show some skill labels when nothing is selected
          skills.slice(0, Math.min(12, skills.length)).forEach(n=>{
            const [x,y] = pos.get(n.id);
            labels.push({
              text: n.label,
              x: x, y: y,
              priority: 1,
              color: '#666666',
              font: '11px "Segoe UI", "Helvetica Neue", Arial, sans-serif',
              offsetX: 8, offsetY: -6
            });
          });
        }
        
        // Sort by priority (higher priority first)
        labels.sort((a, b) => b.priority - a.priority);
        
        // Calculate label dimensions and positions
        const labelRects = [];
        const placedLabels = [];
        
        for (const label of labels) {
          ctx.font = label.font;
          const metrics = ctx.measureText(label.text);
          const width = metrics.width;
          const height = 12; // Approximate height
          
          // Try different positions to avoid overlap
          const positions = [
            { x: label.x + label.offsetX, y: label.y + label.offsetY }, // Default position
            { x: label.x - width - 5, y: label.y + label.offsetY }, // Left side
            { x: label.x + label.offsetX, y: label.y - height - 5 }, // Above
            { x: label.x + label.offsetX, y: label.y + height + 5 }, // Below
            { x: label.x - width/2, y: label.y - height - 5 }, // Centered above
            { x: label.x - width/2, y: label.y + height + 5 }, // Centered below
          ];
          
          let placed = false;
          for (const pos of positions) {
            const rect = {
              x: pos.x,
              y: pos.y - height/2,
              width: width,
              height: height,
              text: label.text,
              color: label.color,
              font: label.font
            };
            
            // Check for collisions with placed labels
            let collision = false;
            for (const placedRect of placedLabels) {
              if (rectsOverlap(rect, placedRect)) {
                collision = true;
                break;
              }
            }
            
            if (!collision) {
              placedLabels.push(rect);
              placed = true;
              break;
            }
          }
          
          // If still no position found, place it anyway (overlap is better than no label)
          // For ego network labels (when node is selected), always place them even if they overlap
          if (!placed || (selectedNode && label.priority >= 1)) {
            const rect = {
              x: label.x + label.offsetX,
              y: label.y + label.offsetY - height/2,
              width: width,
              height: height,
              text: label.text,
              color: label.color,
              font: label.font
            };
            placedLabels.push(rect);
          }
        }
        
        // Draw all placed labels with better readability
        for (const rect of placedLabels) {
          ctx.font = rect.font;
          
          // Add subtle white stroke for better contrast
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.lineWidth = 2;
          ctx.strokeText(rect.text, rect.x, rect.y + rect.height/2);
          
          // Draw the main text
          ctx.fillStyle = rect.color;
          ctx.fillText(rect.text, rect.x, rect.y + rect.height/2);
        }
      }
      
      function rectsOverlap(rect1, rect2) {
        const margin = 3; // Add small margin to prevent tight spacing
        return !(rect1.x + rect1.width + margin < rect2.x ||
                rect2.x + rect2.width + margin < rect1.x ||
                rect1.y + rect1.height + margin < rect2.y ||
                rect2.y + rect2.height + margin < rect1.y);
      }
      
      drawLabelsWithAvoidance();
    }

    async function setSemanticSeed(seed) {
      semanticSeed = seed;
      similarityScores = new Map();
      const seedVec = TOKEN_VECS.get(norm(seed));
      if (!seedVec) { render(); return; }
      const useMap = includeStaff ? STAFF_CARD_VECS : CARD_VECS;
      const scores = [];
      const aNorm = Math.hypot(...seedVec);
      if (!aNorm) { render(); return; }
      for (const [name, vec] of useMap.entries()) {
        const bNorm = Math.hypot(...vec);
        if (!bNorm) { continue; }
        let dot = 0; for (let i = 0; i < seedVec.length && i < vec.length; i++) dot += seedVec[i] * vec[i];
        scores.push([name, dot / (aNorm * bNorm)]);
      }
      scores.sort((x,y)=>y[1]-x[1]);
      similarityScores = new Map(scores);
      render();
    }

    function getNodeAtPosition(x, y, data) {
      const canvas = byId('net');
      const W = canvas.width, H = canvas.height;
      const cx = W/2, cy = H/2, R1 = Math.min(W,H)*0.42;
      const people = data.map(r => ({ id: 'p:'+r.name, label: r.name, type:'person', ref:r }));
      const skillsSet = new Set(); data.forEach(r => r.offer.forEach(s => skillsSet.add(s)));
      const skills = Array.from(skillsSet).map(s => ({ id: 's:'+s, label: s, type:'skill' }));
      const expertiseGroups = new Map();
      data.forEach(r => { if (r.expertise_groups) { Object.keys(r.expertise_groups).forEach(group => { if (!expertiseGroups.has(group)) expertiseGroups.set(group, new Set()); r.expertise_groups[group].forEach(skill => { expertiseGroups.get(group).add(skill); }); }); } });
      if (expertiseGroups.size === 0) expertiseGroups.set('General', skillsSet);
      const P = people.length || 1; const pos = new Map();
      people.forEach((n,i)=>{ const a = (i/P) * Math.PI*2; pos.set(n.id, [cx + R1*Math.cos(a), cy + R1*Math.sin(a)]); });
      const groupArray = Array.from(expertiseGroups.entries());
      groupArray.forEach(([groupName, groupSkills], groupIndex) => {
        const groupSkillsArray = Array.from(groupSkills);
        const R2 = Math.min(W,H) * (0.15 + (groupIndex * 0.08));
        const S = groupSkillsArray.length || 1;
        groupSkillsArray.forEach((skill, skillIndex) => { const a = (skillIndex/S) * Math.PI*2; pos.set('s:'+skill, [cx + R2*Math.cos(a), cy + R2*Math.sin(a)]); });
      });
      for (const person of people) { const [px, py] = pos.get(person.id); const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2); if (dist <= 7) return person; }
      for (const skill of skills) { const [sx, sy] = pos.get(skill.id); const size = 12; if (x >= sx - size/2 && x <= sx + size/2 && y >= sy - size/2 && y <= sy + size/2) return skill; }
      return null;
    }

    function handleCanvasClick(event) {
      const canvas = byId('net');
      const rect = canvas.getBoundingClientRect();
      const x = (event.clientX - rect.left) * (canvas.width / rect.width);
      const y = (event.clientY - rect.top) * (canvas.height / rect.height);
      const data = filteredData();
      const clickedNode = getNodeAtPosition(x, y, data);
      if (includeStaff) { showOrder2 = event.shiftKey; } else { showOrder2 = true; }
      if (clickedNode) {
        if (selectedNode && selectedNode.id === clickedNode.id) { selectedNode = null; showOrder2 = false; qEl.value = ''; query = ''; }
        else { selectedNode = clickedNode; qEl.value = selectedNode.label; query = selectedNode.label; }
        renderNetworkSketch(); render();
      } else { selectedNode = null; showOrder2 = false; qEl.value = ''; query = ''; renderNetworkSketch(); render(); }
    }

    function showToast(msg) {
      const toast = document.getElementById('toast'); toast.textContent = msg; toast.style.display = 'block'; setTimeout(() => toast.style.display = 'none', 3800);
    }

    async function loadStaticData() {
      try {
        if (includeStaff) {
          // Load staff dataset
          const [staffRecs, staffCardVecs] = await Promise.all([
            fetch('data/staff_records.json').then(r=>r.json()).catch(()=>[]),
            fetch('data/staff_card_vectors.json').then(r=>r.json()).catch(()=>({}))
          ]);
          DATA = Array.isArray(staffRecs) ? staffRecs : (staffRecs.records || []);
          CARD_VECS = new Map(Object.entries(staffCardVecs).map(([k,v]) => [k, new Float32Array(v)]));
        } else {
          // Load ECR dataset
          const [ecrRecords, cardVecs] = await Promise.all([
            fetch('data/ecr_records.json').then(r=>r.json()).catch(()=>[]),
            fetch('data/card_vectors.json').then(r=>r.json()).catch(()=>({}))
          ]);
          DATA = Array.isArray(ecrRecords) ? ecrRecords : (ecrRecords.records || []);
          CARD_VECS = new Map(Object.entries(cardVecs).map(([k,v]) => [k, new Float32Array(v)]));
        }

        // Load token vectors (shared)
        const tokenVecs = await fetch('data/token_vectors.json').then(r=>r.json()).catch(()=>({}));
        TOKEN_VECS = new Map(Object.entries(tokenVecs).map(([k,v]) => [norm(k), new Float32Array(v)]));

        console.log(`Loaded ${DATA.length} records, includeStaff: ${includeStaff}`);
        
        // Update record counter
        const countEl = byId('recordCount');
        if (countEl) {
          countEl.textContent = DATA.length;
        }
      } catch (e) {
        console.error('Error loading data:', e);
        showToast('Failed to load data.');
        DATA = [];
        
        // Update record counter to 0 on error
        const countEl = byId('recordCount');
        if (countEl) {
          countEl.textContent = '0';
        }
      }
      
      allSkillsOffered = uniq(flatten(DATA.map(r => r.offer))).sort((a,b)=>a.localeCompare(b));
      allMethods = uniq(flatten(DATA.map(r => r.methods))).sort((a,b)=>a.localeCompare(b));
      allSoftware = uniq(flatten(DATA.map(r => r.software))).sort((a,b)=>a.localeCompare(b));
      render();
    }

    function render() {
      if (activeView === 'list') { listEl.style.display = 'grid'; skillEl.style.display = 'none'; renderList(); }
      else { listEl.style.display = 'none'; skillEl.style.display = 'block'; renderSkillView(); }
      renderNetworkSketch();
    }

    document.querySelectorAll('.tab').forEach(t => t.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
      t.classList.add('active'); activeView = t.dataset.view; render();
    }));

    let h; qEl.addEventListener('input', () => {
      query = qEl.value; if (selectedNode && selectedNode.label !== query) { selectedNode = null; }
      clearTimeout(h); h = setTimeout(render, 150);
    });

    document.getElementById('randomConnect').addEventListener('click', () => {
      const data = DATA; const byOffer = new Map();
      data.forEach(r => r.offer.forEach(s => { if (!byOffer.has(s)) byOffer.set(s, []); byOffer.get(s).push(r); }));
      const skills = Array.from(byOffer.keys()).filter(s => byOffer.get(s).length > 1);
      if (!skills.length) { showToast('No skills with multiple people found.'); return; }
      const skill = skills[Math.floor(Math.random()*skills.length)];
      const people = byOffer.get(skill);
      const p1 = people[Math.floor(Math.random()*people.length)];
      const p2 = people.filter(p => p.name !== p1.name)[Math.floor(Math.random()*(people.length-1))];
      showToast(`Try connecting: ${p1.name} â†” ${p2.name} (both offer ${skill})`);
      qEl.value = skill; query = skill; selectedNode = null; render();
    });

    document.addEventListener('DOMContentLoaded', () => {
      const canvas = byId('net');
      canvas.addEventListener('click', handleCanvasClick);
      canvas.style.cursor = 'pointer';
      const toggle = byId('datasetToggle');
      const statusEl = byId('datasetStatus');
      if (toggle) {
        toggle.addEventListener('click', () => {
          includeStaff = !includeStaff;
          toggle.classList.toggle('active', includeStaff);
          console.log('Toggle clicked, includeStaff:', includeStaff);
          
          // Update status text
          if (statusEl) {
            statusEl.textContent = includeStaff ? '(IIASA Staff only)' : '(ECR only)';
          }
          
          // Update network instructions
          const shiftInstructions = byId('shiftInstructions');
          if (shiftInstructions) {
            shiftInstructions.style.display = includeStaff ? 'inline' : 'none';
          }
          
          // Reload data for the selected dataset
          loadStaticData();
        });
      }
    });

    // Initial load
    loadStaticData();
  </script>
</body>
</html>


